<!DOCTYPE HTML>

<html>

<head>
	<title>PorterBLE</title>
	<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>
	<script>
		$(function () {
			var numFeatures = $('.feature-container').length;
			var currentFeature = 0;

			$('.prev-btn').click(function () {
				$('.feature-container').eq(currentFeature).hide();
				currentFeature = (currentFeature - 1 + numFeatures) % numFeatures;
				$('.feature-container').eq(currentFeature).show();
			});

			$('.next-btn').click(function () {
				$('.feature-container').eq(currentFeature).hide();
				currentFeature = (currentFeature + 1) % numFeatures;
				$('.feature-container').eq(currentFeature).show();
			});
		});
	</script>
	<meta charset="utf-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
	<link rel="stylesheet" href="../assets/css/main.css" />
	<link rel="icon" href="../images/web icon.ico">
	<noscript>
		<link rel="stylesheet" href="../assets/css/noscript.css" />
	</noscript>
</head>

<body class="is-preload">
	<div id="page-wrapper">

		<!-- Header -->
		<header id="header">
			<h1 id="logo"><a href="../index.html" class="images"><img src="../images/ApianLogoWhite.png" alt=""
						width="155" height="55" style="background:transparent; padding: 10px;" /></a></h1>
			<nav id="nav">
				<ul>
					<li><a href="#top" class="button primary">Back to Top</a></li>
					<li>
						<a href="../About.html">About</a>
						<ul>
							<li><a href="../About.html#one">Project Abstract</a></li>
							<li><a href="../About.html#two">Project Video</a></li>
							<li><a href="../About.html#three">Development Team</a></li>
							<li><a href="../About.html#four">Project Management</a></li>
						</ul>
					</li>
					<li>
						<a href="../Requirements.html">Requirements</a>
						<ul>
							<li><a href="../Requirements.html#one">Background</a></li>
							<li><a href="../Requirements.html#two">Goals</a></li>
							<li><a href="../Requirements.html#three">Requirement Gathering</a></li>
							<li><a href="../Requirements.html#four">Use Cases</a></li>
							<li><a href="../Requirements.html#five">Personas</a></li>
							<li><a href="../Requirements.html#six">MoSCoW</a></li>
						</ul>
					</li>
					<li>
						<a href="../Research.html">Research</a>
						<ul>
							<li><a href="../Research.html#one">Related Projects</a></li>
							<li><a href="../Research.html#two">Technology Review</a></li>
							<li><a href="../Research.html#three">Bibliography</a></li>
						</ul>
					</li>
					<li>
						<a href="../Algorithms.html">Algorithms</a>
						<ul>
							<li><a href="../#">one</a></li>
							<li><a href="../#">two</a></li>
							<li><a href="../#">three</a></li>
						</ul>
					</li>
					<li>
						<a href="../UI.html">UI</a>
						<ul>
							<li><a href="../UI.html#one">Interface Requirements</a></li>
							<li><a href="../UI.html#two">Sketches</a></li>
							<li><a href="../UI.html#three">Figma</a></li>
							<li><a href="../UI.html#four">Final Product</a></li>
						</ul>
					</li>
					<li>
						<a href="../System.html">System</a>
						<ul>
							<li><a href="../System.html#architecture">Architecture</a></li>
							<li><a href="../System.html#site-map">Site Map</a></li>
							<li><a href="../System.html#sequence-diagram">Sequence Diagrams</a></li>
							<li><a href="../System.html#data-storage">Data Storage</a></li>
							<li><a href="../System.html#discussion">Design Discussion</a></li>
							<li><a href="../System.html#detailed">Detailed Architecture</a></li>
						</ul>
					</li>
					<li>
						<a class="active" href="../Implementation.html">Implementation</a>
						<ul>
							<li>
								<a href="../Implementation/AndroidAppArticle.html">Android App</a>

							</li>
							<li>
								<a href="../Implementation/FrontendArticle.html">Frontend</a>

							</li>
							<li>
								<a href="../Implementation/BackendArticle.html">Backend</a>

							</li>
						</ul>
					</li>
					<li>
						<a href="../Testing.html">Testing</a>
						<ul>
							<li><a href="../Testing.html#unit-testing">Unit Testing</a></li>
							<li><a href="../Testing.html#device-compat-testing">Device Compatibility Testing</a></li>
							<li><a href="../Testing.html#manual-testing">Manual Testing</a></li>
							<li><a href="../Testing.html#integration-testing">Integration Testing</a></li>
							<li><a href="../Testing.html#user-testing">User Acceptance Testing</a></li>
						</ul>
					</li>
					<li>
						<a href="../Evaluation.html">Evaluation</a>
						<ul>
							<li><a href="../Evaluation.html#one">Achievement Summary</a></li>
							<li><a href="../Evaluation.html#two">Evaluation</a></li>
							<li><a href="../Evaluation.html#three">Future Work</a></li>
						</ul>
					</li>
					<li>
						<a href="../Appendices.html">Appendices</a>
						<ul>
							<li><a href="../Appendices/UserManual.html">User Manual</a></li>
							<li><a href="Appendices/DeploymentManual.html">Deployment Manual</a></li>
							<li><a href="Appendices/PorterBLE Legal Statement.pdf">GPDR and Privacy</a></li>
							<li><a href="Research.html">Development Blog</a></li>
							<li><a href="Research.html">Monthly Videos</a></li>
						</ul>
					</li>
				</ul>
			</nav>
		</header>

		<!-- Main -->
		<div id="main" class="wrapper style2">
			<div class="container">
				<header class="major">
					<h2>Requirements</h2>
					<p>The process of defining and refining project requirements.</p>
					<!--todo111 fix ordering of section on this page-->
				</header>
				<div class="row gtr-150">
					<div class="col-2 col-8-medium">

						<!-- Sidebar -->
						<section id="sidebar">
							<section>
								<h3>Contents</h3>
								<ol class="actions">
									<li><a href="#requirements">Requirements</a></li>
									<li><a href="#approach">Initial Approach</a></li>
									<li><a href="#code-structure">Code Structure</a></li>
									<li><a href="#live-monitoring">Live Monitoring</a></li>
									<li><a href="#floor-plan">Floor plan</a></li>
									<li><a href="#beacons-locations">Beacons and Locations</a></li>
									<li><a href="#porters-deliveries">Porters and Deliveries</a></li>
									<li><a href="#firebase-hosting">Firebase Hosting</a></li>
									<li><a href="#final-implementation">Final Implementation</a></li>
								</ol>
								<br>
							</section>


						</section>

					</div>
					<div class="col-8 col-12-medium imp-medium">

						<section id="requirements">
							<h2>Requirements</h2>
							<p>
								When it comes to implementing a frontend for a software application, there are several
								important requirements that must be taken into consideration. These requirements ensure
								that
								the frontend is not only visually appealing and user-friendly but also functional,
								efficient. Implementing a frontend that
								meets these requirements is crucial for providing a high-quality user experience and
								maximizing the usability and accessibility of the application. In this article, we will
								discuss some of the key requirements for implementing a frontend and how we addressed
								them
								in our application.
							</p>
							<h4>
								Must have:
							</h4>
							<ul>
								<li>Display the live locations of all the porters</li>
								<li>Display the delivery requests and their status</li>
								<li>Ability to request a delivery</li>
								<li>Ability to add and remove porters from the system</li>
								<li>Ability to add and remove beacons from the system</li>
							</ul>
							<h4>
								Should have:
							</h4>
							<ul>
								<li>User should be able to get real-time feedback about porters' responses</li>
								<li>Ability to add and remove transport locations from the system</li>
							</ul>
							<h4>
								Could have:
							</h4>
							<ul>
								<li>Ability to assign deliveries according to priority</li>
								<li>See the live locations of all crash calls/integrate into Crash 2222 calls.</li>
								<li>Ability to track individual high priority assets</li>
							</ul>
							<h2>Main Tools & Dependencies</h2>
							<div class="techRow">
								<div class="techItem">
									<a href="https://react.dev/">
										<img src="../images/tech/React.png">
										<p>React was our framework of choice for developing a frontend application
										</p>
									</a>
								</div>
								<div class="techItem">
									<a href="https://firebase.google.com/docs/hosting">
										<img src="../images/tech/firebase.jpg">
										<p>Firebase Hosting was used to host our frontend website in production
										</p>
									</a>
								</div>
								<div class="techItem">
									<a href="https://nodejs.org/">
										<img src="../images/tech/Nodejs.png">
										<p><br/>Node.js was used as our backend runtime environment</p>
									</a>
								</div>
								<div class="techItem">
									<a href="https://www.npmjs.com/">
										<img src="../images/tech/npm.png">
										<p>npm was our package manager for installing & managing
											dependencies</p>
									</a>
								</div>
							</div>
						</section>
						<section id="approach">
							<h2>Initial Approach</h2>
							<p>
								In our initial approach to implementing the frontend for our application, we evaluated
								several
								popular frameworks to determine which one would best meet our needs. After careful
								consideration, we
								decided on React due to its popularity, performance, and availability of a large and
								active
								developer community. Additionally, some team members had previous experience with React,
								which
								made
								it a natural choice for our application. By choosing React, we were able to create
								reusable
								components and efficient updates, resulting in a user-friendly and responsive
								application that
								met
								the requirements of our users.
							</p>
						</section>
						<section id="code-structure">
							<h2>Code Structure</h2>
							<p>
								Our project's code structure is designed to promote modularity and reusability, with
								separate
								files for each of the pages and reusable components such as forms and tables. This
								approach
								allowed us to create a clean and organized codebase, making it easier to maintain and
								update our
								application over time.

								Each page of our application has its own file, containing all the necessary components,
								styling,
								and logic for that page. This approach allowed us to keep our code organized and easy to
								understand, making it easier for team members to work on different parts of the
								application
								independently.

								In addition, we created reusable components such as forms and tables, which we used
								across
								multiple pages. By creating these components, we were able to reduce duplicate code and
								promote
								consistency across our application.
							</p>
							<img src="../images/codeStructureFrontend.jpg">
						</section>
						<section id="live-monitoring">
							<h2>Live Monitoring</h2>
							<div class="techRow">
								<div class="techItem">
									<a href="https://www.npmjs.com/package/react-stomp">
										<img src="../images/tech/react-stomp.png">
										<p>We utilized the react-stomp library<br/>to implement websocket functionality.
										</p>
									</a>
								</div>
								<div class="techItem">
									<a href="https://en.wikipedia.org/wiki/WebSocket">
										<img src="../images/tech/websocket.jpg">
										<p>We used websockets to keep porter<br/> info up-to-date.
										</p>
									</a>
								</div>
							</div>
							<p>
								In our application, we utilized websockets to receive real-time updates about the
								location and
								status of porters. Websockets are a bi-directional communication protocol that allows
								for
								efficient and seamless data transfer between the server and client. This means that our
								frontend
								was able to receive instant updates about porter positions and any status updates.
							</p>
							<p>
								By using websockets, we were able to ensure that our application was always up-to-date
								with the
								latest information, providing users with real-time tracking of porter positions. This
								was
								particularly important for our application, which required fast and seamless updates to
								ensure
								that users could track porter locations accurately and efficiently.
							</p>
							<p>
								To implement the websockets in our React frontend, we used the react-stomp library. This
								library
								provided a convenient and efficient way to set up and manage websockets within our
								application,
								allowing us to easily receive real-time updates about the location and status of
								porters.
							</p>
						</section>
						<section id="floor-plan">
							<h2>Floor Plan</h2>
							<div class="techRow">
								<div class="techItem">
									<a href="https://reactnative.dev/docs/intro-react">
										<img src="../images/tech/React-component.jpg">
										<p>React components were crucial in re-using our floor plan across our frontend.
										</p>
									</a>
								</div>
								<div class="techItem">
									<a href="https://js.devexpress.com/Documentation/Guide/React_Components/DevExtreme_React_Components/">
										<img src="../images/tech/dev-extreme.jpg">
										<p>We utilized the devextreme-react library to draw up our initial floor plan.
										</p>
									</a>
								</div>
							</div>
							<h3>Initial Attempt</h3>
							<p>
								In our application, we implemented the floor plan initially using the devextreme-react
								library, which allowed us to draw a basic plan and add interactive elements to it:
							</p>
							<img width="60%" src="../images/old floorplan.png">	
							<p>
								However, we encountered limitations when trying to display markers on the plan, which required more flexibility
								than the library could provide. Furthermore, it became very clear that in hospital settings, a floor plan
								would be much more complex in terms of room layout, as well as having multiple buildings and floors. Our concerns
								were proven to be true when our client handed us over a two-floor plan of Wansbeck Hospital, the hospital where
								our project would be initially deployed.<br/>
								
								With the future expandability of our web app in mind, it would be wrong to base our entire solution on just one
								hospital floor plan, breaking it down into individual room components and floors and storing everything, which
								would also take a considerable amount of time to fetch from our backend and load.<br/>

								As a result, we decided to display each floor of the hospital as an image, and overlay circular markers on top
								of it to act as porter, beacon or delivery locations.<br/>
								
								To implement this, we coded the floor plan using Javascript and CSS, whilst also exporting it into a React
								component to be used in our Live Monitoring, Beacons and Deliveries page.
							</p>
							<h3>Overlaying Markers on Top of the Floor Plan</h3>
							<p>
								As mentioned previously, with future expandability in mind, we wanted to create an interactive map that would scale
								perfectly no matter the original resolution of the image, how zoomed into the image a user was, or how scaled an image
								is by the page that uses it. Hence, we stored the marker's positions as x and y percentage offsets from the top left
								of the image rather than storing them as x and y pixel values.
								This allowed us to add a 'zoom in/out' functionality for hospital staff to observe a more detailed delivery tracking view.
								Additionally, it gave us the advantage that markers would always appear correctly positioned on the floor plan, even if it
								was loaded in multiple sizes across our web app. This approach also ensured that the interactive map would scale correctly
								regardless of the image's resolution, and enabled us to avoid having to store and fetch individual room components and
								floors.							
							</p>
							<img src="../images/marker code.JPG">	
							<p>
								The 'calculateMarkerPosition' function above is what is responsible to convert markers' percentage offsets (markerPosition.x
								and markerPosition.y) to dynamic pixel values depending on the current resolutions of the image (imageSize.width and imageSize.height),
								the zoomLevel a hospital staff member is currently using and the percentage an image is restricted by in the floor plan component(
								This is usually 100% to indicate no restriction but sometimes images with extremely large resolutions provided need to be scaled
								down before they are exported).
							</p>
							<h3>Adding Delivery Locations and Beacons to the Floor Plan</h3>
							<p>
								To make it simple for hospital staff to indicate where they have placed physical beacons on a floorplan or point out where deliveries
								should be picked up from and delivered to, we added functionality to our component, so that if it is called from the 'Beacons' or
								'Deliveries' page, a beacon marker appears when the map is clicked, and users can save this beacon and its corresponding MAC-address:
							</p>
							<img style="width: 80%;" src="../images/beacon selection.gif">
							<h3>Final Product</h3>
							<img src="../images/floorPlan.jpg">
						</section>
						<section id="beacons-locations">
							<h2>Beacons and Locations</h2>
							<p>
								In our application, we needed to provide the ability to add beacons and locations by
								specifying
								their position
								on the floor plan, as well as a list component to view all beacons and locations in the
								system.
								Functionality of beacons and locations were very similar, so we were able to
								reuse many of the components we had already developed.
							</p>
							<p>
								To add a beacon or location, users could simply click on the position on the floor plan
								where
								they wanted to
								place the beacon or location, and fill out a form to provide additional information such
								as the
								location name
								or beacon MAC adress. This information was then sent to the backend where it was saved
								in the
								database, and the newly added item would appear on
								the floor plan and in the list component.
							</p>
						</section>
						<section id="porters-deliveries">
							<h2>Porters and Delivery Requests</h2>
							<p>
								Unlike beacons and locations, our porters and delivery requests did not need to be positioned
								on the
								floor plan. This
								made the implementation of these features more straightforward, as we did not need to
								incorporate any specific floor plan functionality.

								To add a new porter or delivery, users simply filled out a form providing relevant
								information
								such as their name, phone number or delivery locations. This information was then sent
								to the
								backend server
								where it was saved to the database, and
								displayed in the appropriate list component.
							</p>
							<p>
								As with the beacon and location feature, we were able to reuse some of the same
								components we
								had developed
								for other parts of our application, such as the form and table components. This enabled
								us to
								maintain a consistent user interface and code structure throughout our project.
							</p>
						</section>
						<section id="firebase-hosting">
							<h2>Firebase Hosting</h2>
							<p>
								After we completed the development of our application, we needed to choose a platform to
								host
								our frontend. We ultimately decided on Firebase Hosting, which allowed us to deploy our
								frontend
								code easily and efficiently. We configured our hosting settings in the firebase.json
								file, which
								allowed us to specify custom rules and configurations for our deployment. One of the
								most
								beneficial features of Firebase Hosting was its ability to automatically deploy our code
								in the
								pipeline on every code commit, which helped to ensure that our app was always up-to-date
								and
								running smoothly. By choosing Firebase Hosting, we were able to streamline our
								deployment
								process and make it much more efficient.
							</p>
							<img src="../images/tech/firebaseHostingDiagram.png">
						</section>
						<section id="final-implementation">
							<h2>Final implementation</h2>
							<p>
								Due to time constraints, we were only able to implement all the must-have and
								should-have
								features within the given timeline. While we would have loved to implement all the
								could-have
								features, such ability to assign deliveries according to priority, integrating Crash
								calls,
								and ability to track individual high-priority
								assets, we had to prioritize our efforts to ensure the
								core functionality of the application was working properly.

								Despite not being able to complete all of the could-have features, we were proud of what
								we were
								able to accomplish within the project timeline. By focusing on the most important
								aspects of the
								application, we were able to create a reliable and user-friendly tool that hospital
								staff could
								use to streamline their daily operations.
							</p>
						</section>
						<br />
						<br />

						</section>
					</div>
				</div>
			</div>
		</div>

		<!-- Footer -->
		<!-- Footer -->
		<footer id="footer">
			<ul class="icons">
				<li><a href="https://github.com/ApianxUCL" class="icon brands alt fa-github"><span
							class="label">GitHub</span></a></li>
			</ul>
		</footer>

	</div>

	<!-- Scripts -->
	<script src="../assets/js/jquery.min.js"></script>
	<script src="../assets/js/jquery.scrolly.min.js"></script>
	<script src="../assets/js/jquery.dropotron.min.js"></script>
	<script src="../assets/js/jquery.scrollex.min.js"></script>
	<script src="../assets/js/browser.min.js"></script>
	<script src="../assets/js/breakpoints.min.js"></script>
	<script src="../assets/js/util.js"></script>
	<script src="../assets/js/main.js"></script>

</body>

</html>
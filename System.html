<!DOCTYPE HTML>

<html>
	<head>
		<title>PorterBLE</title>
		<meta charset="utf-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
		<link rel="stylesheet" href="assets/css/main.css" />
		<link rel="icon" href="images/web icon.ico">
		<noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
	</head>
	<body class="is-preload">
		<div id="page-wrapper">

			<!-- Header -->
				<header id="header">
				<h1 id="logo"><a href="index.html" class="images"><img src="images/ApianLogoWhite.png" alt="" width="155" 
					height="55" style="background:transparent; padding: 10px;"/></a></h1>
					<nav id="nav">
						<ul>
							<li><a href="#top" class="button primary">Back to Top</a></li>
							<li>
								<a href="About.html">About</a>
								<ul>
									<li><a href="About.html#one">Project Abstract</a></li>
									<li><a href="About.html#two">Project Video</a></li>
									<li><a href="About.html#three">Development Team</a></li>
									<li><a href="About.html#four">Project Management</a></li>
								</ul>
							</li>
							<li>
								<a href="Requirements.html">Requirements</a>
								<ul>
									<li><a href="Requirements.html#one">Background</a></li>
									<li><a href="Requirements.html#two">Goals</a></li>
									<li><a href="Requirements.html#three">Requirement Gathering</a></li>
									<li><a href="Requirements.html#four">Use Cases</a></li>
									<li><a href="Requirements.html#five">Personas</a></li>
									<li><a href="Requirements.html#six">MoSCoW</a></li>
								</ul>
							</li>
							<li>
								<a href="Research.html">Research</a>
								<ul>
									<li><a href="Research.html#one">Related Projects</a></li>
									<li><a href="Research.html#two">Technology Review</a></li>
									<li><a href="Research.html#three">Bibliography</a></li>
								</ul>
							</li>
							<li>
								<a href="UI.html">UI</a>
								<ul>
									<li><a href="UI.html#one">Interface Requirements</a></li>
									<li><a href="UI.html#two">Sketches</a></li>
									<li><a href="UI.html#three">Figma</a></li>
									<li><a href="UI.html#four">Final Product</a></li>
								</ul>
							</li>
							<li>
								<a class="active" href="System.html">System</a>
								<ul>
									<li><a href="System.html#architecture">Architecture</a></li>
									<li><a href="System.html#site-map">Site Map</a></li>
									<li><a href="System.html#sequence-diagram">Sequence Diagrams</a></li>
									<li><a href="System.html#data-storage">Data Storage</a></li>
									<li><a href="System.html#discussion">Design Discussion</a></li>
									<li><a href="System.html#detailed">Detailed Architecture</a></li>
								</ul>
							</li>
							<li>
								<a href="Implementation.html">Implementation</a>
								<ul>
									<li>
										<a href="Implementation/AndroidAppArticle.html">Android App</a>
										
									</li>
									<li>
										<a href="Implementation/FrontendArticle.html">Frontend</a>
										
									</li>
									<li>
										<a href="Implementation/BackendArticle.html">Backend</a>
										
									</li>
								</ul>
							</li>
							<li>
								<a href="Testing.html">Testing</a>
								<ul>
									<li><a href="Testing.html#unit-testing">Unit Testing</a></li>
									<li><a href="Testing.html#device-compat-testing">Device Compatibility Testing</a></li>
									<li><a href="Testing.html#manual-testing">Manual Testing</a></li>
									<li><a href="Testing.html#integration-testing">Integration Testing</a></li>					
									<li><a href="Testing.html#user-testing">User Acceptance Testing</a></li>
								</ul>
							</li>
							<li>
								<a href="Evaluation.html">Evaluation</a>
								<ul>
									<li><a href="Research.html#one">Achievement Summary</a></li>
									<li><a href="Research.html#two">Evaluation</a></li>
									<li><a href="Research.html#three">Future Work</a></li>
								</ul>
							</li>
							<li>
								<a href="Appendices.html">Appendices</a>
								<ul>
									<li><a href="Appendices/UserManual.html">User Manual</a></li>
									<li><a href="Appendices/DeploymentManual.html">Deployment Manual</a></li>
									<li><a href="Appendices/PorterBLE Legal Statement.pdf">GPDR and Privacy</a></li>
									<li><a href="Research.html">Development Blog</a></li>
									<li><a href="Research.html">Monthly Videos</a></li>
								</ul>
							</li>
						</ul>
					</nav>
				</header>

			<!-- Main -->
				<div id="main" class="wrapper style2">
					<div class="container">
						<header class="major">
							<h2>System Design</h2>
							<p>Building the ideal system for our solution.</p>
						</header>
						<div class="row gtr-150">
							<div class="col-2 col-8-medium">

								<!-- Sidebar -->
								<section id="sidebar">
									<section>
										<h3>Contents</h3>
										<ol class="actions">
											<li><a href="#architecture">Architecture</a></li>
											<li><a href="#site-map">Site Map</a></li>
											<li><a href="#sequence-diagram">Sequence Diagrams</a></li>
											<li><a href="#data-storage">Data Storage</a></li>
											<li><a href="#discussion">Design Discussion</a></li>
											<li><a href="#detailed">Detailed Architecture</a></li>
										</ol>
										<br>
									</section>

									
								</section>

							</div>
							<div class="col-8 col-12-medium imp-medium">

								<h3>Our solution consists of a <b>mobile application</b> and a <b>web application</b>:</h3>
								</p>
								<b>MOBILE APPLICATION</b>
								<p>
									Porters will have our mobile phone application installed on their work phones. This application is
									split into two fragments:
								<ul>
									<li><b>Login Fragment: </b>Handles all the logic for a porter to securely login into our PorterBLE
										system,
										including the use of a one-time authentication pin. Once a user has been authenticated, the app
										then
										establishes a secure, two-way Firebase connection with our web application, so that the two can
										communicate
										swiftly and securely.</li>
									<li><b>Scanner Fragment: </b>Scans for Bluetooth beacons and updates the backend with the latest
										beacon information
										every 5 seconds. Allows porters to declare themselves as available/unavailable for deliveries,
										accept or reject
										incoming delivery requests and also indicate that they have completed a delivery.</li>
								</ul>
								<b>WEB APPLICATION</b>
								<p>
									Our web application is hosted on Firebase, as per our clients' request. It consists of a frontend
									and backend:
								<ul>
								<li><b>Frontend: </b>
									Displays live multi-floor hospital floorplan with real-time porter location updates and allows
									hospital staff to create
									and track delivery requests. Allows for the registering of porters, beacons and delivery
									locations on the hospital
									map. Also has all the relevant documentation for porters to download, setup and use our mobile
									application.
								</li>
								<li><b>Backend: </b>
									Stores all relevant porter, beacon and delivery location information. Maintains Twilio service
									for one-time pin SMS
									generation and distribution. Also responsible for porter authentication through Firebase Cloud
									Messaging (FCM) token
									exchange.
								</li>
								</ul>
								
								<section id="architecture">
									<h3>System Architecture</h3>
									<p>It was crucial for us to plan out a system architecture that would facilitate swift communication
										between our mobile
										application and web application.
									</p>

									
									<span class="image fit main bottom"><img src="./images/System Architecture Diagram.png" alt=""
											class="systemBg" />
										<p class="descriptionSystem">Figure 1: System Architecture Overview.
										</p>
									</span>
								</section>
								<section id="site-map">
									<h2>Site Map</h2>
									<p>Our aim, as with all other components was to make our website as intuitive to use as possible. It
										was imperative to do so,
										as in a hospital setting, staff will want to navigate our applications as swiftly as possible;
										we did not want to design
										some complex-looking solution which would slow their performance and potentially cause longer
										waiting times for patients.<br /><br />
										Therefore, we separated our website into the following tabs:
									<ul>
										<li>
											Live Monitoring: Allows hospital staff to view real-time porter locations on multi-floor
											hospital map and make requests to them.
										</li>
										<li>
											Deliveries: Allows hospital staff track the details including status of current and
											completed deliveries.
										</li>
										<li>
											Beacons: Allows hospital staff to indicate where in the hospital physical beacons have been
											placed.
										</li>
										<li>
											Locations: Allows hospital staff to indicate where on the floorplan delivery locations are.
										</li>
										<li>
											Mobile Application: Allows hospital staff to download the Android APK for our solution, as
											well as view instructions on how to
											install, setup and use it.
										</li>
									</ul>
										</p>
										<span class="image fit main bottom"><img src="./images/Site Map.png" alt="" class="systemBg2" />
											<p class="descriptionSystem">Figure 2: Web Application Site Map.
											</p>
										</span>
									</section>
									<section id="sequence-diagram">
										<h2>Sequence Diagrams</h2>
										<span class="image fit main bottom"><img src="./images/LiveLocationUpdatesSequenceDiagram.png" alt="" class="systemBg4" />
											<p class="descriptionSystem">Figure 3: Live location updates sequence diagram.
											</p>
										</span>
										<span class="image fit main bottom"><img src="./images/OneTimePinFlow.png" alt="" class="systemBg4" />
											<p class="descriptionSystem">Figure 4: One time pin flow sequence diagram
											</p>
										</span>
									</section>
									<section id="data-storage">
										<h2>Data Storage</h2>
										<p>
											We chose a relational database because our data has a clear structure and can be organized into
											tables with defined relationships. For example, each Porter can have multiple Deliveries
											assigned to them, and each Delivery has a Location associated with it. Additionally, we have a
											OneTimePin entity that has a one-to-one relationship with each Porter, to facilitate
											authentication. By using a relational database, we can easily maintain the relationships between
											these entities, and efficiently query and update our data.
										</p>
										<span class="image fit main bottom"><img src="./images/ER Diagram.png" alt="" class="systemBg3" />
											<p class="descriptionSystem">Figure 5: ER Diagram.
											</p>
										</span>
									</section>
									<section id="discussion">
										<h2>System Design Discussion</h2>
										<h3>Web Application</h3>
										With regards to our web application, usability and delivery speed were our two main concerns. We are
										proud to have
										designed a web application that hospital staff can use to quickly create delivery requests which are
										fulfilled at a
										quick pace due to our efficient porter selection request system in the backend. A brief overview of
										the
										web app:
										<br />
										<br />
										<b>Frontend</b>
										<p>In the world of software development, choosing the right technology stack is crucial for creating
											successful and scalable applications. Recently, we had the opportunity to build a frontend for
											our
											application using the React JavaScript framework, and it was an excellent decision for our
											team.<br />

											React is a popular open-source JavaScript library that allows developers to build user
											interfaces
											(UI) by breaking down complex UI elements into smaller, reusable components. React's virtual DOM
											efficiently updates the UI and delivers a smooth user experience. It is also highly
											customizable,
											allowing developers to add third-party libraries, which can speed up development time.<br />

											We chose React for several reasons. Firstly, it is an efficient tool for developing complex
											applications that require many UI elements and interactions. Additionally, the use of components
											in
											React makes it easier to reuse code and maintain consistency across the application.<br />

											Another significant advantage of React is that it is well-documented and supported by a large
											community of developers. This means that when we encountered any issues or needed to add new
											features, we had a vast array of resources available to help us.<br /><br />

											For our application, we also needed to receive instant updates about a porter's position and any
											delivery responses. To achieve this, we used websockets, which are a technology that enables
											real-time communication between a client and a server.<br />

											Websockets allowed us to receive updates from the server without having to make frequent
											requests for
											new data. This not only reduced server load but also improved the overall user experience by
											providing real-time information.<br />

											We started by creating a WebSocket instance in our React component and then using the
											'react-stomp'
											library to connect to the server. We then set up event listeners for incoming data and used the
											state to update the UI when the server sent new information.<br /><br />

											Overall, using React and websockets proved to be an excellent combination for our application's
											frontend. React allowed us to create a highly responsive and customizable UI, while websockets
											enabled real-time communication with the server, which was crucial for our application's
											functionality.<br />

											In conclusion, choosing the right technology stack is a crucial decision for building successful
											applications. React's ability to create complex UI elements using reusable components and its
											large
											community of developers make it an excellent choice for building frontend applications.
											Additionally, the use of websockets allows for real-time communication and reduces server load,
											which ultimately improves the user experience.<br /><br />

											As well as using React and websockets, we also hosted our application using Firebase.
											Firebase provides a simple and reliable way to host web
											applications and provides several useful features such as authentication, cloud storage.<br />

											Hosting our application using Firebase was a straightforward process. We first created a
											Firebase
											account and then used the Firebase CLI to deploy our application. We also configured our
											Firebase
											project to use SSL to ensure that our application was secure.<br />

											Firebase's hosting service also provides automatic scaling, which means that our application can
											handle traffic spikes without any additional configuration. This is essential for ensuring that
											our
											application is always available, even during peak usage.</p>

										<b>Backend</b>

										<p>In today's digital age, creating scalable and reliable backend services is essential for building
											successful applications. Recently, we had the opportunity to design our backend service using
											the Spring
											Boot framework, Google Cloud SQL PostgreSQL for a database, and deployed our app with Google
											Cloud Run.<br />

											Spring Boot is a popular open-source Java framework that allows developers to create standalone,
											production-grade applications quickly. It is designed to simplify the development process by
											providing
											preconfigured libraries and tools for building web applications.<br />

											One of the reasons we chose Spring Boot was its simplicity and ease of use. The framework's
											auto-configuration and starter dependencies allow developers to quickly build and deploy
											applications
											with minimal configuration. Additionally, Spring Boot's community support and extensive
											documentation
											make it an excellent choice for building robust backend services.<br />

											For our database, we chose Google Cloud SQL PostgreSQL. PostgreSQL is a popular open-source
											relational
											database management system that is known for its reliability, scalability, and extensibility.
											Google
											Cloud SQL is a fully managed relational database service that makes it easy to set up, maintain,
											and
											administer PostgreSQL databases on Google Cloud Platform.<br />

											Google Cloud SQL PostgreSQL provides several useful features, such as automatic backups,
											replication,
											and high availability, that ensure our application's data is always available and secure.
											Additionally,
											the integration with Google Cloud Platform allows for easy scaling and maintenance of our
											database,
											which is crucial for handling large amounts of data.<br /><br />

											To deploy our application, we chose Google Cloud Run, a serverless compute platform that enables
											developers to run containers in a fully managed environment. Cloud Run abstracts away the
											underlying
											infrastructure, which allows developers to focus on writing code rather than managing
											servers.<br />

											Google Cloud Run also provides automatic scaling, which means our application can handle traffic
											spikes
											without any additional configuration. This is essential for ensuring that our backend service is
											always
											available and responsive, even during peak usage.<br />

											Our backend service receives updates from the users through the mobile app and sends processed
											updates
											to the UI. It also sends SMS messages and push notifications to the porters. To achieve this, we
											used
											several APIs and services, such as Twilio for sending SMS messages and Firebase Cloud Messaging
											for push
											notifications.<br /><br />

											Overall, using Spring Boot, Google Cloud SQL PostgreSQL, and deploying our app with Google Cloud
											Run
											proved to be an excellent combination for designing our backend service. Spring Boot's
											simplicity and
											ease of use allowed us to quickly build and deploy our application, while Google Cloud SQL
											PostgreSQL
											and Google Cloud Run provided a scalable and reliable infrastructure for our database and
											backend
											service.<br />

											By using these technologies, we were able to create a robust backend service that processed
											updates from
											the mobile app, sent notifications to the porters, and updated the UI in real-time. We were also
											able to
											scale our application automatically, ensuring that our service was always available and
											responsive to
											user requests.<br /><br />
										</p>
										<h3>Mobile Application</h3>
										<p>
											The development of the app started with the choice of the Kotlin programming language, which has
											recently become the preferred language
											for Android app development. Kotlin is a modern, statically typed language that is designed to
											make Android app development more efficient
											and less error-prone. Its interoperability with Java made it an ideal language for our system as
											it allowed us leverage existing Java libraries,
											such as the Bluetooth Low Energy and Firebase libraries, while taking advantage of Kotlin's
											development features, like extension functions and
											coroutines.<br />
											As our mobile application depended on making frequent HTTP requests to our backend API endpoint,
											our system design relied heavily on Kotlin’s
											coroutine features and HTTP classes to implement multithreading capabilities which would allow
											our application to run separate HTTP requests
											simultaneously if necessary.<br />
											Our system also relied on Kotlin’s BLE API which allowed our app to successfully detect nearby
											Bluetooth Low Energy beacons; a feature that
											was imperative for our solution.
										</p>
										<p>
											For more details and technical information about our implementation, you can read <a
												href="Implementation.html">our implementation articles</a>
											which explain how each component of our system was created.
										</p>
									</section>
									<section id="detailed">
										<h2>Detailed system overview</h2>
										<p>For more details regarding what each component of our system is responsible for, please consult
											the image
											below:
										</p>
										<span class="image fit main bottom"><img src="./images/System Architecture.png" alt="" class="systemBg" />
											<p class="descriptionSystem">Figure 6: Detailed System Architecture Component Description.
											</p>
										</span>
									</section>
							</div>
						</div>
					</div>
				</div>

			<!-- Footer -->
				<!-- Footer -->
				<footer id="footer">
					<ul class="icons">
						<li><a href="https://github.com/ApianxUCL" class="icon brands alt fa-github"><span class="label">GitHub</span></a></li>
					</ul>
				</footer>

		</div>

		<!-- Scripts -->
			<script src="assets/js/jquery.min.js"></script>
			<script src="assets/js/jquery.scrolly.min.js"></script>
			<script src="assets/js/jquery.dropotron.min.js"></script>
			<script src="assets/js/jquery.scrollex.min.js"></script>
			<script src="assets/js/browser.min.js"></script>
			<script src="assets/js/breakpoints.min.js"></script>
			<script src="assets/js/util.js"></script>
			<script src="assets/js/main.js"></script>

	</body>
</html>